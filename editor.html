<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor - BrainLog</title>
    <link rel="stylesheet" href="./style.css" />
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ§ </text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script>
        // Init Theme immediately to prevent flash
        (function() {
            const saved = localStorage.getItem('brainlog_theme');
            const sys = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const theme = (saved === 'system' || !saved) ? (sys ? 'dark' : 'light') : saved;
            document.documentElement.setAttribute('data-theme', theme);
        })();
    </script>
</head>
<body class="flex flex-col items-center justify-center h-screen overflow-hidden p-4 mode-paragraph">

    <div class="w-full max-w-2xl shadow-xl rounded-lg flex flex-col h-full max-h-[85vh] editor-container">
        
        <div id="editor-wrapper" class="flex-grow overflow-y-auto px-8 relative">
            <div id="focus-overlay"></div>
            <div id="editable-area" 
                 contenteditable="true" 
                 data-placeholder="Start writing..." 
                 spellcheck="false">
            </div>
        </div>

        <div id="app-footer" class="w-full px-6 py-3 flex justify-between items-center text-sm z-20 relative">
            <div id="daily-progress-container" title="Daily Goal Progress">
                <div id="daily-progress-bar"></div>
            </div>
            <div class="flex items-center gap-3">
                <a id="back-btn" href="index.html" class="footer-btn p-1.5 rounded" title="Back to Notes">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
                    </svg>
                </a>

                <button id="toggle-mode-btn" class="footer-btn px-3 py-1.5 rounded text-xs font-medium tracking-wide">
                    Mode: Paragraph
                </button>
                
                <div id="save-indicator"></div>
            </div>

            <div class="flex items-center gap-4">
                <div id="stats" class="flex gap-4 text-xs font-medium text-neutral-500">
                    <span id="word-count">0 words</span>
                    <span id="sentence-count">0 sentences</span>
                </div>
                <button id="download-markdown-btn" class="footer-btn p-1.5 rounded" title="Download as Markdown">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
                    </svg>
                </button>
                <button id="zen-mode-btn" class="footer-btn p-1.5 rounded" title="Toggle Zen Mode">
                    <svg id="icon-enter-zen" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
                    </svg>
                    <svg id="icon-exit-zen" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5M15 15l5.25 5.25" />
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { db } from './src/db.js';
        const body = document.body;
        const wrapper = document.getElementById('editor-wrapper');
        const editableArea = document.getElementById('editable-area');
        const overlay = document.getElementById('focus-overlay');
        const toggleBtn = document.getElementById('toggle-mode-btn');
        const wordCountEl = document.getElementById('word-count');
        const sentenceCountEl = document.getElementById('sentence-count');
        const saveIndicatorEl = document.getElementById('save-indicator');

        const STORAGE_KEY = 'elegant_writer_notes';
        const KEY_MODE = 'elegant_writer_mode';
        const STATS_KEY = 'brainlog_stats';
        
        // --- STATE VARIABLES ---
        let saveTimeout;
        let visualTimeout;
        const SAVE_DELAY = 1000;
        const PULSE_DURATION = 1200;

        const urlParams = new URLSearchParams(window.location.search);
        const NOTE_ID = urlParams.get('id');

        let currentMode = 'paragraph'; 
        let activeBlock = null;
        
        // Scroll State
        let isAutoScrolling = false;
        let scrollTimeout;

        // Stats State
        let sessionStart = null;
        let lastKeyTime = null;
        let sessionKeys = 0;
        let startWordCount = 0;

        // --- DATA HELPERS ---
        function getNotes() {
            return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        }

        // --- STATS ENGINE ---
        function initStats() {
            const text = editableArea.innerText || "";
            startWordCount = countWords(text);
            
            if (!localStorage.getItem(STATS_KEY)) {
                localStorage.setItem(STATS_KEY, JSON.stringify({
                    totalWords: 0,
                    wpmAvg: 0,
                    totalSessions: 0,
                    daily: {}
                }));
            }
        }

        function countWords(str) {
            const matches = str.match(/\b\w+\b/g);
            return matches ? matches.length : 0;
        }

        function updateTracking() {
            const now = Date.now();
            
            // 1. Track Typing Speed (Bursts)
            if (!sessionStart || (now - lastKeyTime > 5000)) {
                sessionStart = now;
                sessionKeys = 0;
            }
            sessionKeys++;
            lastKeyTime = now;

            const durationMin = (now - sessionStart) / 60000;
            if (durationMin > 0.1) { 
                const currentWpm = (sessionKeys / 5) / durationMin;
                saveWpm(currentWpm);
            }

            // 2. Track Word Count Delta
            const currentText = editableArea.innerText || "";
            const currentCount = countWords(currentText);
            const delta = currentCount - startWordCount;

            if (delta !== 0) {
                saveWordStats(delta);
                startWordCount = currentCount; 
            }
        }

        function saveWordStats(delta) {
            const stats = JSON.parse(localStorage.getItem(STATS_KEY));
            const today = new Date().toISOString().split('T')[0];
            if (!stats.daily[today]) stats.daily[today] = 0;
            stats.daily[today] += delta;
            stats.totalWords += delta;
            localStorage.setItem(STATS_KEY, JSON.stringify(stats));
        }

        function saveWpm(currentWpm) {
            if (currentWpm > 150 || currentWpm < 5) return;
            const stats = JSON.parse(localStorage.getItem(STATS_KEY));
            const oldWpm = stats.wpmAvg || 0;
            stats.wpmAvg = oldWpm === 0 ? currentWpm : (oldWpm * 0.95) + (currentWpm * 0.05);
            localStorage.setItem(STATS_KEY, JSON.stringify(stats));
        }

        // --- SAVE LOGIC ---
        function queueSave() {
            clearTimeout(saveTimeout);
            clearTimeout(visualTimeout);
            saveIndicatorEl.innerHTML = ''; 
            saveTimeout = setTimeout(performSave, SAVE_DELAY);
        }

        function performSave() {
            if (!NOTE_ID) return;
            const notes = getNotes();
            const noteIndex = notes.findIndex(n => n.id === NOTE_ID);

            if (noteIndex > -1) {
                notes[noteIndex].content = editableArea.innerHTML;
                notes[noteIndex].updatedAt = Date.now();
                localStorage.setItem(STORAGE_KEY, JSON.stringify(notes));
                db.pushItem(notes[noteIndex]);
                db.updateProfile();

                renderStatus('saving');
                visualTimeout = setTimeout(() => { renderStatus('saved'); }, PULSE_DURATION);
            }
        }

        function renderStatus(state) {
            if (state === 'saving') {
                saveIndicatorEl.innerHTML = `<div class="status-saving"></div>`;
            } else if (state === 'saved') {
                saveIndicatorEl.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 status-saved" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 12l5 5l10 -10"></path><path d="M2 12l5 5m5 -5l5 -5"></path></svg>`;
            }
        }

        // --- EDITOR CORE ---
        function loadContent() {
            const savedMode = localStorage.getItem(KEY_MODE);
            if (savedMode && (savedMode === 'paragraph' || savedMode === 'spotlight')) {
                setMode(savedMode);
            }

            if (NOTE_ID) {
                const notes = getNotes();
                const note = notes.find(n => n.id === NOTE_ID);
                
                if (note) {
                    editableArea.innerHTML = note.content;
                    renderStatus('saved');
                    const backBtn = document.getElementById('back-btn');
                    if (backBtn && note.parentId) {
                        backBtn.href = `index.html?folder=${note.parentId}`;
                    }
                } else {
                    alert("Note not found.");
                    editableArea.innerHTML = '<div><br></div>';
                }
            } else {
                window.location.href = 'index.html';
            }
            ensureStructure();
        }

        function setMode(mode) {
            currentMode = mode;
            if (mode === 'spotlight') {
                body.classList.replace('mode-paragraph', 'mode-spotlight');
                toggleBtn.textContent = 'Mode: Spotlight';
            } else {
                body.classList.replace('mode-spotlight', 'mode-paragraph');
                toggleBtn.textContent = 'Mode: Paragraph';
            }
            localStorage.setItem(KEY_MODE, currentMode);
        }

        toggleBtn.addEventListener('click', () => {
            if (currentMode === 'spotlight') {
                setMode('paragraph');
            } else {
                setMode('spotlight');
            }
            updateFocus();
            forceCenter();
        });

        function updateFocus() {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;

            let node = selection.anchorNode;
            while (node && node.parentNode !== editableArea) {
                node = node.parentNode;
            }

            if (currentMode === 'paragraph') {
                if (node && node.nodeName === 'DIV') {
                    if (activeBlock !== node) {
                        if (activeBlock) activeBlock.classList.remove('active-block');
                        node.classList.add('active-block');
                        activeBlock = node;
                    }
                }
            }
            
            if (currentMode === 'spotlight') {
                const range = selection.getRangeAt(0);
                const rect = range.getBoundingClientRect();
                let top = rect.top;
                let bottom = rect.bottom;

                if (rect.height === 0 && node) {
                    const parentRect = node.getBoundingClientRect();
                    top = parentRect.top;
                    bottom = parentRect.bottom;
                }

                const wrapperRect = wrapper.getBoundingClientRect();
                const relativeTop = top - wrapperRect.top + wrapper.scrollTop;
                const relativeBottom = bottom - wrapperRect.top + wrapper.scrollTop;
                const padding = 8; 
                overlay.style.setProperty('--focus-top', `${relativeTop - padding}px`);
                overlay.style.setProperty('--focus-bottom', `${relativeBottom + padding}px`);
            }
        }

        function syncOverlaySize() {
            if (currentMode === 'spotlight') {
                overlay.style.height = `${editableArea.scrollHeight}px`;
            }
        }

        function scrollEngine(instant = false) {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;

            let targetRect = null;
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            
            if (rect.top !== 0 || rect.bottom !== 0) {
                targetRect = rect;
            } else if (activeBlock) {
                targetRect = activeBlock.getBoundingClientRect();
            }
            if (!targetRect && editableArea.lastChild && editableArea.lastChild.nodeType === Node.ELEMENT_NODE) {
                targetRect = editableArea.lastChild.getBoundingClientRect();
            }

            if (!targetRect) return;

            const wrapperRect = wrapper.getBoundingClientRect();
            const relativeTop = targetRect.top - wrapperRect.top;
            const targetY = wrapperRect.height / 2;
            const offset = relativeTop - targetY + (targetRect.height / 2);

            if (Math.abs(offset) > 1) {
                // Flag auto-scroll so reading mode doesn't trigger
                isAutoScrolling = true;
                clearTimeout(scrollTimeout);

                if (instant) {
                    wrapper.scrollTop += offset; 
                } else {
                    wrapper.scrollTo({ top: wrapper.scrollTop + offset, behavior: 'smooth' }); 
                }

                scrollTimeout = setTimeout(() => { isAutoScrolling = false; }, 500);
            }
        }

        function forceCenter() {
            scrollEngine(true);
        }

        // --- EVENT LISTENERS ---
        
        // 1. Scroll Detection (Reading Mode)
        wrapper.addEventListener('scroll', () => {
            if (!isAutoScrolling && !body.classList.contains('is-scrolling')) {
                body.classList.add('is-scrolling');
            }
        }, { passive: true });

        // 2. Typing Detection
        editableArea.addEventListener('keydown', (e) => {
            // Exit reading mode instantly
            if (body.classList.contains('is-scrolling')) {
                body.classList.remove('is-scrolling');
            }

            if (e.key === 'Enter') {
                setTimeout(() => {
                    ensureStructure();
                    updateFocus();
                    scrollEngine(true); 
                    queueSave(); 
                }, 0);
            }
        });

        const handleInput = (e) => {
            updateTracking(); // Track stats
            ensureStructure();
            syncOverlaySize();
            updateFocus();
            updateStats();
            queueSave(); 
            if (e.inputType !== 'insertParagraph') {
                requestAnimationFrame(() => scrollEngine(false)); 
            }
        };

        const handleInteraction = () => {
            if (document.activeElement === editableArea) {
                updateFocus();
                requestAnimationFrame(() => scrollEngine(false));
            }
        };

        function ensureStructure() {
            if (!editableArea.firstChild || editableArea.innerHTML.trim() === '') {
                editableArea.innerHTML = '<div><br></div>';
            }
        }

        function updateStats() {
            // 1. Standard Doc Stats
            const text = editableArea.innerText || "";
            const words = text.match(/\b\w+\b/g);
            const wc = words ? words.length : 0;
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const sc = sentences.length;

            // Always show document stats in the text
            wordCountEl.textContent = `${wc} ${wc === 1 ? 'word' : 'words'}`;
            sentenceCountEl.textContent = `${sc} ${sc === 1 ? 'sentence' : 'sentences'}`;

            // 2. Ambient Bar Logic
            const dailyGoal = parseInt(localStorage.getItem('brainlog_daily_goal') || 0);
            const barContainer = document.getElementById('daily-progress-container');
            const bar = document.getElementById('daily-progress-bar');

            if (dailyGoal > 0) {
                // Fetch daily stats
                const stats = JSON.parse(localStorage.getItem(STATS_KEY) || '{"daily":{}}');
                const today = new Date().toISOString().split('T')[0];
                const dailyTotal = stats.daily[today] || 0;

                // Calculate % (capped at 100%)
                const percentage = Math.min((dailyTotal / dailyGoal) * 100, 100);
                
                // Update CSS
                bar.style.width = `${percentage}%`;
                barContainer.style.display = 'block';

                barContainer.title = `Daily Progress: ${dailyTotal} / ${dailyGoal} words`;

                if (percentage >= 100) {
                    bar.className = 'goal-met';
                } else if (percentage > 0) {
                    bar.className = 'active';
                } else {
                    bar.className = '';
                }
            } else {
                barContainer.style.display = 'none';
            }
        }

        function setCursorToEnd() {
            const range = document.createRange();
            const selection = window.getSelection();
            if(editableArea.lastChild) {
                range.selectNodeContents(editableArea);
                range.collapse(false);
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }

        // --- ZEN MODE LOGIC ---
        const zenBtn = document.getElementById('zen-mode-btn');
        const iconEnter = document.getElementById('icon-enter-zen');
        const iconExit = document.getElementById('icon-exit-zen');

        function toggleZenMode() {
            if (!document.fullscreenElement) {
                // ENTER ZEN
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable full-screen mode: ${err.message}`);
                });
                
                // Update Classes
                body.classList.add('zen-mode');
                document.documentElement.classList.add('zen-active'); // Fixes Gutter
                
                // Swap Icons
                iconEnter.classList.add('hidden');
                iconExit.classList.remove('hidden');

            } else {
                // EXIT ZEN
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
                
                // Update Classes
                body.classList.remove('zen-mode');
                document.documentElement.classList.remove('zen-active'); // Restores Gutter
                
                // Swap Icons
                iconEnter.classList.remove('hidden');
                iconExit.classList.add('hidden');
            }
        }

        zenBtn.addEventListener('click', toggleZenMode);

        // Listen for "Escape" key (Browser native exit)
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                // Ensure UI syncs up if user pressed ESC
                body.classList.remove('zen-mode');
                iconEnter.classList.remove('hidden');
                iconExit.classList.add('hidden');
            }
        });

        editableArea.addEventListener('input', handleInput);
        document.addEventListener('selectionchange', handleInteraction);
        window.addEventListener('resize', () => { syncOverlaySize(); updateFocus(); forceCenter(); });

        editableArea.addEventListener('paste', (e) => {
            e.preventDefault();
            const text = (e.clipboardData || window.clipboardData).getData('text/plain');
            document.execCommand('insertText', false, text);
            handleInput({ inputType: 'insertText' });
        });

        document.getElementById('download-markdown-btn').addEventListener('click', () => {
            let markdown = "";
            const lines = editableArea.querySelectorAll('div');
            
            // Generate Markdown Content
            lines.forEach((line, index) => {
                let text = line.innerText.replace(/\n/g, ''); 
                
                // If it's the first line, make it an H1 in markdown too
                if (index === 0 && text.trim().length > 0) {
                    markdown += `# ${text}\n\n`;
                } else {
                    markdown += text;
                    if (index < lines.length - 1) markdown += "\n\n";
                }
            });

            // Generate Filename from First Line
            const firstLine = lines[0]?.innerText.trim() || 'Untitled';
            // Sanitize filename (remove special chars, replace spaces with dashes)
            const safeName = firstLine.replace(/[^a-z0-9]/gi, '-').toLowerCase().substring(0, 30);
            const fileName = safeName.length > 0 ? `${safeName}.md` : `note-${Date.now()}.md`;

            const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName; // <--- Uses the smart name
            a.click();
            URL.revokeObjectURL(url);
        });

        window.addEventListener('DOMContentLoaded', () => {
            loadContent();
            ensureStructure();
            setCursorToEnd();
            editableArea.focus(); 
            updateStats();
            syncOverlaySize();
            updateFocus();
            initStats(); // Init stats engine

            let attempts = 0;
            const centerInterval = setInterval(() => {
                forceCenter();
                attempts++;
                if (attempts > 5) {
                    clearInterval(centerInterval);
                    wrapper.classList.add('ready');
                }
            }, 20);
        });

        // --- ZEN MODE MOUSE TRACKING ---
        let zenMouseTimeout;

        document.addEventListener('mousemove', () => {
            // Only run if we are actually in Zen Mode
            if (!body.classList.contains('zen-mode')) return;

            // 1. Show the UI
            body.classList.add('zen-ui-visible');

            // 2. Clear any existing timer to hide it
            clearTimeout(zenMouseTimeout);

            // 3. Set a new timer to hide it again after 2 seconds of inactivity
            zenMouseTimeout = setTimeout(() => {
                // Check if user is hovering the footer directly (optional safety)
                // We let CSS :hover handle the persistence, so we can just remove the class
                body.classList.remove('zen-ui-visible');
            }, 2000);
        });

    </script>
</body>
</html>